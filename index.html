<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF Compressor (Client‑side) — Single File</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#06b6d4;--muted:#94a3b8;--glass:rgba(255,255,255,0.03)}
    html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:linear-gradient(180deg,#071428 0%, #07172a 60%);color:#e6eef6}
    .wrap{max-width:980px;margin:20px auto;padding:18px;}
    header{display:flex;gap:12px;align-items:center}
    h1{font-size:1.15rem;margin:0}
    p.lead{margin:6px 0 18px;color:var(--muted);font-size:0.95rem}.card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:14px;padding:14px;box-shadow:0 6px 30px rgba(2,6,23,0.6);}

form.controls{display:grid;grid-template-columns:1fr 120px;gap:12px;align-items:center}
@media (max-width:600px){form.controls{grid-template-columns:1fr} }

.file-row{display:flex;gap:8px;align-items:center}
input[type=file]{display:none}
.btn{display:inline-flex;gap:8px;align-items:center;padding:10px 12px;border-radius:10px;background:linear-gradient(90deg,var(--accent),#0ea5b5);color:#052024;font-weight:600;border:none;cursor:pointer}
.btn.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);font-weight:600}

label.file-label{display:inline-block;padding:10px 12px;border-radius:10px;background:var(--glass);border:1px dashed rgba(255,255,255,0.04);cursor:pointer;color:var(--muted)}

.form-row{display:flex;gap:12px;align-items:center;margin-top:12px}
.field{flex:1}
.small{font-size:0.85rem;color:var(--muted)}

.progress{height:10px;background:rgba(255,255,255,0.04);border-radius:999px;overflow:hidden}
.progress > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#7dd3fc);width:0%}

.output{margin-top:14px;display:flex;flex-direction:column;gap:8px}
.meta{font-size:0.9rem;color:var(--muted)}

footer{margin-top:18px;font-size:0.85rem;color:var(--muted)}

/* small helpers */
.muted{color:var(--muted)}
.center{display:flex;align-items:center;gap:8px}

  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="card" style="padding:10px 14px;display:flex;align-items:center;gap:12px">
        <svg width="36" height="36" viewBox="0 0 24 24" fill="none" aria-hidden>
          <rect x="2" y="3" width="20" height="18" rx="2" stroke="white" stroke-opacity="0.06"/>
          <path d="M7 8h10M7 12h10M7 16h6" stroke="white" stroke-opacity="0.12" stroke-linecap="round"/>
        </svg>
        <div>
          <h1>PDF Compressor — client-side</h1>
          <p class="lead">Select a PDF, choose an image quality and compress it right in your browser. No files uploaded to a server.</p>
        </div>
      </div>
    </header><main style="margin-top:14px">
  <section class="card">
    <div class="file-row">
      <label class="file-label" for="fileInput">Choose PDF</label>
      <input id="fileInput" type="file" accept="application/pdf">
      <div style="margin-left:auto" class="center">
        <button id="compressBtn" class="btn" disabled>Compress</button>
        <button id="resetBtn" class="btn secondary">Reset</button>
      </div>
    </div>

    <div class="form-row">
      <div class="field">
        <label class="small">Image quality (rasterized pages): <strong id="qLabel">0.75</strong></label>
        <input id="quality" type="range" min="0.15" max="1" step="0.05" value="0.75" />
        <div class="small muted">Lower quality -> smaller files. Very low quality can make text fuzzy.</div>
      </div>

      <div style="width:140px">
        <label class="small">Max width (px)</label>
        <input id="maxWidth" type="number" value="1200" min="300" max="3000" style="width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit">
      </div>
    </div>

    <div style="margin-top:12px">
      <label class="small">Options</label>
      <div style="display:flex;gap:10px;margin-top:8px;flex-wrap:wrap">
        <label style="display:inline-flex;gap:8px;align-items:center"><input id="singlePass" type="checkbox" checked> Fast (single-pass render)</label>
        <label style="display:inline-flex;gap:8px;align-items:center"><input id="greyscale" type="checkbox"> Convert to greyscale</label>
        <label style="display:inline-flex;gap:8px;align-items:center"><input id="removeLinks" type="checkbox"> Remove links/annotations</label>
      </div>
    </div>

    <div style="margin-top:12px">
      <div class="progress" aria-hidden><i id="bar"></i></div>
      <div class="output">
        <div class="meta" id="meta">No file chosen</div>
        <a id="downloadLink" class="btn" style="display:none" download="compressed.pdf">Download compressed PDF</a>
      </div>
    </div>
  </section>

  <footer>
    Tip: this tool rasterizes each page and rebuilds a PDF client-side using canvas -> images. It works great for scanned PDFs or image-heavy PDFs. For text-first PDFs this will convert text to images (may increase size) — try a mild quality like 0.8 first. No file leaves your device.
  </footer>
</main>

  </div>  <!-- Libraries: pdf.js and jsPDF (CDN). These are widely used in-browser libs. -->  <script src="https://unpkg.com/pdfjs-dist@3.9.179/build/pdf.min.js"></script>  <script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>  <script>
    // Basic client-side PDF compressor by rasterizing pages and creating a new PDF.
    // Uses pdf.js to render pages to canvas and jsPDF to assemble images into a new PDF.

    const fileInput = document.getElementById('fileInput');
    const compressBtn = document.getElementById('compressBtn');
    const resetBtn = document.getElementById('resetBtn');
    const qualityEl = document.getElementById('quality');
    const qLabel = document.getElementById('qLabel');
    const maxWidthEl = document.getElementById('maxWidth');
    const meta = document.getElementById('meta');
    const bar = document.getElementById('bar');
    const downloadLink = document.getElementById('downloadLink');
    const singlePass = document.getElementById('singlePass');
    const greyscale = document.getElementById('greyscale');

    let pickedFile = null;

    qualityEl.addEventListener('input', ()=> qLabel.textContent = qualityEl.value);

    fileInput.addEventListener('change', (e)=>{
      if(!e.target.files || !e.target.files[0]) return;
      const f = e.target.files[0];
      if(f.type !== 'application/pdf'){
        alert('Please choose a PDF file.');
        return;
      }
      pickedFile = f;
      meta.textContent = `Selected: ${f.name} — ${(f.size/1024/1024).toFixed(2)} MB`;
      compressBtn.disabled = false;
      downloadLink.style.display = 'none';
    });

    resetBtn.addEventListener('click', ()=>{
      fileInput.value = '';
      pickedFile = null;
      compressBtn.disabled = true;
      meta.textContent = 'No file chosen';
      bar.style.width = '0%';
      downloadLink.style.display = 'none';
    });

    compressBtn.addEventListener('click', async ()=>{
      if(!pickedFile) return alert('Choose a PDF first.');
      compressBtn.disabled = true;
      resetBtn.disabled = true;
      meta.textContent = 'Reading PDF...';

      try{
        const arrayBuffer = await pickedFile.arrayBuffer();
        const loadingTask = pdfjsLib.getDocument({data:arrayBuffer});
        const pdf = await loadingTask.promise;
        const pageCount = pdf.numPages;
        meta.textContent = `Pages: ${pageCount} — rendering...`;

        // create jsPDF instance. We'll pick portrait/landscape per page dynamically.
        const { jsPDF } = window.jspdf;
        const outPdf = new jsPDF({unit:'pt'}); // use points to match pdf.js canvas px

        for(let i=1;i<=pageCount;i++){
          // update progress
          const pct = Math.round(((i-1)/pageCount)*100);
          bar.style.width = pct + '%';
          meta.textContent = `Rendering page ${i} of ${pageCount}...`;

          const page = await pdf.getPage(i);
          const viewport = page.getViewport({scale:1});
          // compute scale to fit maxWidth
          const targetMaxWidth = Math.max(300, Math.min(3000, Number(maxWidthEl.value)||1200));
          const scale = Math.min( Math.max(0.25, targetMaxWidth / viewport.width), 2 );
          const renderViewport = page.getViewport({scale});

          const canvas = document.createElement('canvas');
          canvas.width = Math.round(renderViewport.width);
          canvas.height = Math.round(renderViewport.height);
          const ctx = canvas.getContext('2d');

          // optional greyscale prefill if requested
          if(greyscale.checked){
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0,0,canvas.width,canvas.height);
          }

          const renderContext = {
            canvasContext: ctx,
            viewport: renderViewport
          };

          await page.render(renderContext).promise;

          // optionally convert to greyscale by reprocessing pixels
          if(greyscale.checked){
            const imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
            const d = imgData.data;
            for(let p=0;p<d.length;p+=4){
              const r=d[p], g=d[p+1], b=d[p+2];
              const l = (0.299*r + 0.587*g + 0.114*b)|0;
              d[p]=d[p+1]=d[p+2]=l;
            }
            ctx.putImageData(imgData,0,0);
          }

          const mime = 'image/jpeg';
          const q = Math.max(0.05, Math.min(1, Number(qualityEl.value)||0.75));
          const imgData = canvas.toDataURL(mime, q);

          // add to jsPDF. jsPDF expects units we set (pt). convert px to pt: 1px at 96dpi = 0.75pt
          const pxToPt = 0.75;
          const imgWidthPt = canvas.width * pxToPt;
          const imgHeightPt = canvas.height * pxToPt;

          if(i===1){
            // first page: replace blank default page
            outPdf.setPage(1);
            outPdf.deletePage(1);
            outPdf.addPage([imgWidthPt, imgHeightPt]);
            outPdf.addImage(imgData, 'JPEG', 0, 0, imgWidthPt, imgHeightPt, undefined, 'FAST');
          } else {
            outPdf.addPage([imgWidthPt, imgHeightPt]);
            outPdf.addImage(imgData, 'JPEG', 0, 0, imgWidthPt, imgHeightPt, undefined, 'FAST');
          }

          // small delay if singlePass is unchecked to give UI time to update for very large files
          if(!singlePass.checked){
            await new Promise(r=>setTimeout(r,6));
          }

          // free memory
          canvas.width = canvas.height = 0;
        }

        bar.style.width = '98%';
        meta.textContent = 'Finalizing PDF...';

        const blob = outPdf.output('blob');
        const originalSize = pickedFile.size;
        const newSize = blob.size;
        const saved = Math.max(0, ((originalSize - newSize)/originalSize)*100);

        const url = URL.createObjectURL(blob);
        downloadLink.href = url;
        downloadLink.style.display = 'inline-flex';
        downloadLink.textContent = `Download compressed PDF — ${(newSize/1024/1024).toFixed(2)} MB`;
        meta.innerHTML = `Done. Original: ${(originalSize/1024/1024).toFixed(2)} MB → New: ${(newSize/1024/1024).toFixed(2)} MB (${saved.toFixed(1)}% size saved)`;
        bar.style.width = '100%';

      }catch(err){
        console.error(err);
        alert('An error occurred during compression: ' + (err && err.message ? err.message : err));
        meta.textContent = 'Error — see console';
      }finally{
        compressBtn.disabled = false;
        resetBtn.disabled = false;
      }

    });
  </script></body>
</html>